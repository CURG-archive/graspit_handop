/************************************************************************\

  Copyright 1997 The University of North Carolina at Chapel Hill.
  All Rights Reserved.

  Permission to use, copy, modify and distribute this software
  and its documentation for educational, research and non-profit
  purposes, without fee, and without a written agreement is
  hereby granted, provided that the above copyright notice and
  the following three paragraphs appear in all copies.

  IN NO EVENT SHALL THE UNIVERSITY OF NORTH CAROLINA AT CHAPEL
  HILL BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
  INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
  ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
  EVEN IF THE UNIVERSITY OF NORTH CAROLINA HAVE BEEN ADVISED OF
  THE POSSIBILITY OF SUCH DAMAGES.


  Permission to use, copy, modify and distribute this software
  and its documentation for educational, research and non-profit
  purposes, without fee, and without a written agreement is
  hereby granted, provided that the above copyright notice and
  the following three paragraphs appear in all copies.

  THE UNIVERSITY OF NORTH CAROLINA SPECIFICALLY DISCLAIM ANY
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS"
  BASIS, AND THE UNIVERSITY OF NORTH CAROLINA HAS NO OBLIGATION
  TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
  MODIFICATIONS.


   --------------------------------- 
  |Please send all BUG REPORTS to:  |
  |                                 |
  |   geom@cs.unc.edu               |
  |                                 |
   ---------------------------------
  
     
  The authors may be contacted via:

  US Mail:  A. Pattekar/J. Cohen/T. Hudson/S. Gottschalk/M. Lin/D. Manocha
            Department of Computer Science
            Sitterson Hall, CB #3175
            University of N. Carolina
            Chapel Hill, NC 27599-3175
	    
  Phone:    (919)962-1749
	    
  EMail:    geom@cs.unc.edu

\************************************************************************/

/************************************************************************\
Filename: VInternal.H
--
Description: This file declares three classes - VCReportType,
             VCObject and VCInternal.
             VCReportType is a simple class through which
             collisions are reported.
             VCObject holds all the necessary information
             about an object.
             VCInternal contains the implementation of VCollide.

\************************************************************************/


#ifndef VINTERNAL_H
#define VINTERNAL_H

#include "PQP.h"
#include <list>
#include "NBody.H"

#include <qmutex.h>
#include <qthreadstorage.h>
#include <assert.h>

#define VC_THREAD_SUPPORT

//state in which VCollide is:
const int VCstate_default   = 0; //default state
const int VCstate_newObject = 1; //a new object has been created but its
                                 //geometry is yet to be inputted.
const int VCstate_addTri    = 2; //the geometry is being inputted.
const int VCstate_moveTri   = 3; //the geometry is being changed.
const int VCstate_newClone  = 4; //a clone has just been added, no new geometry is necessary


struct VCReportType;
       //multiply defined in VInternal.C, VCollide.H and VCollide.h
       //this was done so that the implementation can be hidden from the
       //user.

/************************************************************************
Class: VCObject
--
Description: Each instance of this class keeps all the necessary 
             information about an object.

\************************************************************************/

class VCObject
{
  friend class VCInternal;
  
private:
  
  int         id;          //the id of the object.
  PQP_Model *b;          
  
  double      trans[4][4]; //the current transformation matrix for the object.

  int         activation_state; //1=>object is activated, 0=>deactivated.
  bool		  isClone;
  int		  threadId; // 0 - main thread; other threads will have other numbers
};


/************************************************************************
Class: VCInternal
--
Description: Each instance of this class maintains information about a
             set of objects and activation/deactivation states between
             them. Collision detection can be performed only on
             objects that belong to the same instance of the this
             class. It uses the NBody class as its back-end.

\************************************************************************/

class VCInternal
{
  int      state;       //the state in which VCollide is.
  int      next_id;     //next free id, since ids are generated by the program.
  int      current_id;  //the id of the object being worked on by "AddTri"
                        //or "EndObject".
  NBody    *nbody;       //pointer to an instance of the NBody class.

  PairData disabled;    //set of disabled pairs.
  int      mSize;        //size of the "vcobjects" array.
  VCObject **vc_objects;//array of pointers to VCObjects.

  int Report(int size, VCReportType *vcrep, PairData *report_data);
                      //translates the results of collision detection.

  int GetEnabledList(PairData *collTests, int *interestList=NULL, 
					 int interestSize = 0, int thisThreadId = 0);

public:
  VCInternal();
  ~VCInternal();

  enum Query{ALL_COLLISIONS, FAST_COLLISION, CONTACTS};

  //! Checks if state is ok for starting a new thread and threading is enabled
  int newThread();
  int ResetObject(int id); //create a new object using an old id
  //create a new object with the given thread id in the database.
  int NewObject(int *id, int threadId=0); 
  //create a new clone with the given thread id in the database.
  int NewClone(int *id, int originalId, int threadId=0); 
  int AddTri(double v1[], double v2[], double v3[],int triInd); //insert the
                                                      //geometry .
  int EndObject(bool ExpectEmpty = false);    //tell VCollide that inserting the 
                          //geometry is complete.
  int EditObject(int id);  //begin editing object geometry
  int EditTri(double v1[], double v2[], double v3[],int triInd); //change
                                                     // the geometry a triangle

  int EditFinished(void); //tell VCollide the geometry changes are done
  int GetObject(int id,double **& vList);  // return # of triangles and all the
                                         // transformed vertices
  PQP_Model *GetModel(int id) {return vc_objects[id]->b;}
  int UpdateTrans(int id, double trans[][4]);
                          //update the transformation matrix of
                          //the object.
  int ActivateObject(int id);       //activate for collision detection.
  int DeactivateObject(int id);     //deactivate from collision detection.
  int ActivatePair(int id1, int id2);  //activate the pair.
  int DeactivatePair(int id1, int id2);//deactivate the pair.

  bool isObjectActivated(int id);
  bool isPairActivated(int id1, int id2);

  int DeleteObject(int id);  //delete the object from the database.

  int AllCollisions(Query q, VCReportType *vc_report, int size, 
					int *interestList = NULL, int interestSize = 0, int thisThreadId = 0);
  int AllContacts(PQP_ContactResult *cresArr, double dist_thresh, 
				  int *interestList = NULL, int interestSize = 0, int thisThreadId = 0);

  int Collision(int id1,int id2, PairData *report_data);
  int Contact(int id1, int id2,double thresh,PQP_ContactResult &cres );

  double Dist(int id1, int id2);  //find min dist between two bodies
  int Dist(int id1, int id2,PQP_DistanceResult &dres,double dist_thresh=-1);

  //cnl- calls the GetNghbdPoints in PQP to get the region around a
  //given point, used in soft contacts, takes the id of the body, the coordinates 
  //of the point in world space, the radius of the desired region, and a pointer
  //to the list which will hold the vertices of the triangles in the region
  //thresh is the tolerance level, it is the same as the distance between two
  //objects considered to be in contact
  void FindRegion( int id1, PQP_REAL pt[3], PQP_REAL normal[3], PQP_REAL rad, 
	  std::vector<PQP_Vec> *ptList );

  double FindShortDist(PQP_REAL pt[3], int id1, PQP_REAL closest_pt[3], PQP_REAL closest_normal[3], PQP_REAL thresh);

  void getBvs(int id, int desiredDepth, std::vector<BV*> *bvs);
};

#endif




