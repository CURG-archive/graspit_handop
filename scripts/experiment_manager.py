import time
import os

import remote_dispatcher,  generation_manager
import eigenhand_db_interface, eigenhand_db_tools, eigenhand_db_objects
import atr, ate
import eigenhand_genetic_algorithm
import task_models, server_list
import examine_database

class ExperimentManager(object):
    def __init__(self, config, task_model_list,
                 eval_functor = ate.weighted_threshold_ATE_hand,
                 server_dict = server_list.clic_lab_dict,
                 task_prototype = eigenhand_db_objects.Task(task_type_id = 4, task_time = -1),
                 db_interface = eigenhand_db_interface.EGHandDBaseInterface()):
        """
        @param num_ga_iters - The number of genetic algorithm generations to run
        @param num_atr_iters - The number of ATR iterations to run for each GA generation
        @param task_model_list - A list of TaskModels used to set up the database planner
        @param task_prototype - A prototype Task object that defines the trial specification(i.e. length and type)
        @param trials_per_task - The number of planning jobs to run for each object/hand pair per planning iteration. Results from each should look fairly unique.
        @param eval_functor - The function to use when evaluating hand fitness in the genetic algorithm
        @param db_interface - The database interface to use. Assumed to be initialized with a starting set of 0th generation hands
        @param starting_ga_iter - The generation to start from.
        @param server_dict - A dictionary whose keys are server urls that will be filled with
                             Servers as connections are made
        """
        self.task_prototype = task_prototype
        self.task_model_list = task_model_list
        self.eval_functor = eval_functor
        self.db_interface = db_interface
        self.config = config
        self.server_dict = server_dict
        self.e_list = dict()

        self.gm = []
        self.rd = []       #self.score_array = numpy.array([4,0])
        
        self.db_interface.update_config(config) 

    def get_current_ga_iteration(self):

        if not self.gm:
            error("ExperimentManager::get_current_ga::no_generation_manager","Error: Generation manager not initialized!")

        return self.gm.generation//self.get_generations_per_ga_iter()

    def get_generations_per_ga_iter(self):
        """
        @brief The generations of the gm counts the number of times a new set of hands is generated. This happens
        num_atr_iters times for each round of ATR and one additional time to generate the new hands for the GA
        totalling num_atr_itrs + 1 per each round of GA
        """
        return self.num_atr_iters + 1

    def get_last_ga_generation(self):
        """
        @brief Get the number of the last generation number of hands that were generated by a genetic algorithm, as opposed to ATR
        """
        ga_iter = self.get_current_ga_iteration()
        ga_generation = self.gm.generation//self.get_generations_per_ga_iter()
        return ga_generation

    def initialize_generation_manager(self):
        """
        @brief Create the generation manager that will be used in this experiment
        """
        return generation_manager.GenerationManager(self.db_interface, self.task_model_list,
                                                    self.starting_ga_iter*self.get_generations_per_ga_iter(),
                                                    self.task_prototype.task_time, self.trials_per_task,
                                                    self.task_prototype.task_type_id,
                                                    self.eval_functor)


    def output_current_status(self):
        filename = '/var/www/eigenhand_project/results'
        self.e_list.update(examine_database.get_e_list(self.gm, [], self.eval_functor))
        score_array = examine_database.e_list_to_score_array(self.e_list)
        examine_database.plot_elist_vs_gen(score_array, filename)


    def run_remote_dispatcher_tasks(self):
        """
        @brief Run the tasks on a cluster using the RemoteDispatcher framework developed for this project.

        """
        #Record the start time
        t = time.time()
        r = 0
        #Test if there are jobs available to do.
        job_num = eigenhand_db_tools.get_num_unlaunched_jobs(self.db_interface)

        #Try to run a new remote dispatcher loop as long as there are unfinished jobs
        while job_num > 2:
            print "Starting Dispatcher Assignment Loop %s"%r
            r += 1
            #Blocks until time runs out or all jobs are finished.
            self.rd.run()
            #Reset any incomplete jobs. These are essentially jobs that we have lost connection with and cannot be
            #relied upon to terminate.
            self.db_interface.reset_incompletes()
            #See how many jobs are still undone.
            job_num = eigenhand_db_tools.get_num_unlaunched_jobs(self.db_interface)
        #If we only have a few stragglers, just stop trying -- We don't really need all of them to exit cleanly,
        #and it is easier to fail gracefully than try to handle every error.
        self.db_interface.set_incompletes_as_error()
        print "done.  Time %f \n"%(time.time() - t)

    def backup_results(self):
        self.db_interface.incremental_backup(experiment_name=self.config.name,generation=self.gm.generation)

    def restore_results(self, generation=0):
        self.db_interface.incremental_restore(experiment_name=self.config.name,generation=self.gm.generation)
    
    def restore_all(self):
        self.db_interface.reset_database()
        self.restore_hands()
        self.restore_all_grasps()

    def restore_to_new_dbase(self):
        self.db_interface.prepare_empty_db(self.experiment_name)
        self.db_interface = eigenhand_db_interface.EGHandDBaseInterface(self.experiment_name)
        self.restore_all()

    def drop_dbase(self):
        self.db_interface.drop_database(self.experiment_name)

    def run_experiment(self):
        """
        @brief Run the whole experiment. Does num_ga_iters genetic algorithm runs each containing num_atr iterations
        of ATR.
        """
        #initialize new generation manager to configure the database to start running.
        self.gm = self.initialize_generation_manager()
        self.gm.start_generation()

        #Build the new remote dispatcher and connect all the servers
        self.rd = remote_dispatcher.RemoteDispatcher(self.db_interface)
        self.rd.init_all_servers(self.server_dict)
        self.run_remote_dispatcher_tasks()

        #Run through a bunch of iterations
        iters_per_generation = self.num_atr_iters + 1
        num_total_iters = (self.num_ga_iters-self.starting_ga_iter)*iters_per_generation

        for iter_num in xrange(num_total_iters):
            #Get the resulting grasps for the latest generation of hands
            grasp_list = self.gm.get_all_grasps()
            self.output_current_status()

            #Pull out our generation numbers
            atr_gen_num = (iter_num)%(iters_per_generation)
            ga_gen_num = iter_num//(iters_per_generation) + self.starting_ga_iter
            ga_loop = (iter_num+1)%(iters_per_generation)==0

            #Every num_atr_iters+1th iteration is a genetic swap
            if not ga_loop:
                #Run atr on the existing hand for the latest generation of grasps
                new_hand_list = atr.ATR_generation(grasp_list, self.gm.hands)
            else:
                #Generate new hands based on these grasps, scaling the variance of the mutations down linearly as the
                #generations progress.
                new_hand_list = eigenhand_genetic_algorithm.GA_generation(grasp_list, self.gm.hands, self.eval_functor, .5-.4/self.num_ga_iters*ga_gen_num)

            #Put the new hands in to the database.
            eigenhand_db_tools.insert_unique_hand_list(new_hand_list, self.db_interface)

            #Backup results and then remove everything from the grasp table
            self.backup_results
            self.clear_tables(['grasp','job'])

            #Run the planner to get grasps for the last set of hands
            self.gm.next_generation()

            #Run the planning jobs
            self.run_remote_dispatcher_tasks()


        self.backup_results()

        self.rd.kill_all_servers()

def new_em(name, ga_iterations, atr_iterations = 5, task_model_names = task_models.tiny_keys):
    config = {'name':name,
              'ga_iterations':ga_iterations,
              'atr_iterations':atr_iterations,
              'trials_per_task':5,
              'task_type_id': 4,
              'task_time': -1,
              'task_models':task_model_names}
    task_model_list = task_models.model_set(task_model_names)
    em = ExperimentManager(config,task_model_list)
    return em

def resume_em():
    db_interface = eigenhand_db_interface.EGHandDBaseInterface()
    config = db_interface.load_config()
    task_model_list = task_models.model_set(config['task_models'])
    em = ExperimentManager(config,task_model_list)
    return em
